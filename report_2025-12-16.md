# 工作报告（2025-12-16）

## 目标
- “哪种更高效就用哪个”：拓扑检查在 Python 与 C++ 后端之间自动选择更快实现，并允许显式强制选择。
- 补齐可复现的回归/冒烟测试用例到 `space_app/test_cases/`。

## 结论（可直接使用）
- 默认行为：`space_app/algorithms/topology.py` 采用 `auto` 模式。
  - 若 `topology_cpp` 可用：首次调用会对同一批要素做一次轻量计时，选更快后端并缓存到进程。
  - 若 `topology_cpp` 不可用：自动回退到 Python。
- 可强制指定：
  - `SPACE_TOPOLOGY_BACKEND=cpp`：强制走 C++（不可用则回退 Python）。
  - `SPACE_TOPOLOGY_BACKEND=python`：强制走 Python。
- 可调 auto 采样规模：`SPACE_TOPOLOGY_AUTO_BENCH_N=300`（默认 300；设为 0 表示 auto 直接偏向 C++）。

## 本次修改内容
- 拓扑入口增加“后端选择器”与缓存：
  - 文件：`space_app/algorithms/topology.py`
  - 新增：
    - `SPACE_TOPOLOGY_BACKEND`（`auto|cpp|python`）
    - `SPACE_TOPOLOGY_AUTO_BENCH_N`（auto 计时采样要素数）
    - 拆分实现为 `_check_topology_layer_cpp` / `_check_topology_layer_python`，便于测试与基准。

- 修复 Python 路径的 bbox 解析兼容性问题：
  - `_iter_xy()` 过去只处理 list，不处理 tuple；而 `extract_lines_from_features()` 内部坐标是 tuple。
  - 结果会导致 `geom_bbox/_layer_bbox` 返回 None，从而 `cross_without_node` 永远检测不到（但 dangling 仍会返回）。
  - 现已支持 `(list, tuple)`，确保 Python 后端结果正确。

- 改进交叉修复覆盖率（尽可能全修）：
  - 早期实现对每条线的交点数量有较小截断，导致“多数交叉未修复”。
  - 现在默认不限制每条线可处理的交点数（尽可能全修）。
  - 若遇到极端数据希望限制运行时间，可设置：`SPACE_TOPOLOGY_MAX_CROSS_PER_LINE=<正整数>`。

## 如何验证（推荐顺序）
1) 跑基准（我们现有的脚本）：
- `python bench_topology.py --n 2000 --repeat 3 --warmup 1`

2) 跑测试用例脚本（不依赖 pytest）：
- `python space_app/test_cases/test_04_topology_backend_force.py`
- `python space_app/test_cases/test_05_topology_backend_auto_smoke.py`

## 新增/更新的测试用例
- `space_app/test_cases/test_04_topology_backend_force.py`
  - 覆盖：强制 Python / 强制 C++（若可用）两条路径能运行，并能识别 `cross_without_node` 与 `dangling_endpoint`。
- `space_app/test_cases/test_05_topology_backend_auto_smoke.py`
  - 覆盖：`auto` 模式首次调用会缓存 `_SELECTED_BACKEND`；native 不可用时必定选 Python。

## 风险与注意事项
- `auto` 的“更快”判定依赖本机/本次数据与 native 的构建优化级别（Debug vs Release）；因此结果可能在不同环境不同。
- 该策略只在进程首次调用时额外做一次双后端执行与计时，后续调用不再重复。
